/**
 * E2E Database Reset Utility
 * Resets the test database to a clean state with seed data
 *
 * Usage: DATABASE_URL=... npx tsx scripts/e2e-db-reset.ts
 *
 * Generated by: create-e2e-docker
 */

<% if (services.database.type === 'postgres') { -%>
import pg from "pg";
<% } else if (services.database.type === 'mysql') { -%>
import mysql from "mysql2/promise";
<% } else if (services.database.type === 'mongodb') { -%>
import { MongoClient } from "mongodb";
<% } -%>
import bcrypt from "bcrypt";
import dotenv from "dotenv";

dotenv.config();

const SALT_ROUNDS = 10;

// Test users to seed
const TEST_USERS = [
<% testUsers.forEach(user => { -%>
  {
    email: "<%= user.email %>",
    password: "<%= user.password %>",
    name: "<%= user.name || 'Test User' %>",
    role: "<%= user.role || 'user' %>",
    verified: <%= user.verified !== false %>,
  },
<% }); -%>
];

<% if (services.database.type === 'postgres') { -%>
async function reset(): Promise<void> {
  const client = new pg.Client({
    connectionString: process.env.DATABASE_URL,
  });

  try {
    await client.connect();
    console.log("Connected to test database");

    // Get all table names (excluding Prisma migration tables)
    const tablesResult = await client.query(`
      SELECT tablename FROM pg_tables
      WHERE schemaname = 'public' AND tablename NOT LIKE '_prisma%'
    `);

    console.log(`Found ${tablesResult.rows.length} tables to truncate`);

    // Truncate all tables
    for (const { tablename } of tablesResult.rows) {
      await client.query(`TRUNCATE TABLE "${tablename}" CASCADE`);
      console.log(`  Truncated: ${tablename}`);
    }

    // Reset sequences
    const sequencesResult = await client.query(`
      SELECT sequencename FROM pg_sequences WHERE schemaname = 'public'
    `);

    for (const { sequencename } of sequencesResult.rows) {
      await client.query(`ALTER SEQUENCE "${sequencename}" RESTART WITH 1`);
    }
    console.log(`Reset ${sequencesResult.rows.length} sequences`);

    // Seed test users
    console.log("\nSeeding test users:");
    for (const user of TEST_USERS) {
      const passwordHash = await bcrypt.hash(user.password, SALT_ROUNDS);
      const result = await client.query(
        `INSERT INTO users (email, password_hash, name, role, email_verified)
         VALUES ($1, $2, $3, $4, $5)
         RETURNING id`,
        [user.email.toLowerCase(), passwordHash, user.name, user.role, user.verified]
      );
      console.log(`  Created: ${user.email} (role: ${user.role}, verified: ${user.verified})`);
    }

    console.log("\n========================================");
    console.log("Database reset complete!");
    console.log("========================================");
    console.log("\nTest credentials:");
<% testUsers.forEach(user => { -%>
    console.log("  <%= user.name || 'User' %>: <%= user.email %> / <%= user.password %>");
<% }); -%>
    console.log("");

  } catch (error) {
    console.error("\nDatabase reset failed:", error);
    process.exit(1);
  } finally {
    await client.end();
  }
}
<% } else if (services.database.type === 'mysql') { -%>
async function reset(): Promise<void> {
  const connection = await mysql.createConnection(process.env.DATABASE_URL!);

  try {
    console.log("Connected to test database");

    // Disable foreign key checks
    await connection.execute("SET FOREIGN_KEY_CHECKS = 0");

    // Get all table names
    const [tables] = await connection.execute<{ TABLE_NAME: string }[]>(
      `SELECT TABLE_NAME as TABLE_NAME FROM information_schema.tables
       WHERE table_schema = DATABASE() AND table_name NOT LIKE '%prisma%'`
    );

    console.log(`Found ${tables.length} tables to truncate`);

    // Truncate all tables
    for (const { TABLE_NAME } of tables) {
      await connection.execute(`TRUNCATE TABLE \`${TABLE_NAME}\``);
      console.log(`  Truncated: ${TABLE_NAME}`);
    }

    // Re-enable foreign key checks
    await connection.execute("SET FOREIGN_KEY_CHECKS = 1");

    // Seed test users
    console.log("\nSeeding test users:");
    for (const user of TEST_USERS) {
      const passwordHash = await bcrypt.hash(user.password, SALT_ROUNDS);
      await connection.execute(
        `INSERT INTO users (email, password_hash, name, role, email_verified)
         VALUES (?, ?, ?, ?, ?)`,
        [user.email.toLowerCase(), passwordHash, user.name, user.role, user.verified]
      );
      console.log(`  Created: ${user.email} (role: ${user.role}, verified: ${user.verified})`);
    }

    console.log("\n========================================");
    console.log("Database reset complete!");
    console.log("========================================");
    console.log("\nTest credentials:");
<% testUsers.forEach(user => { -%>
    console.log("  <%= user.name || 'User' %>: <%= user.email %> / <%= user.password %>");
<% }); -%>
    console.log("");

  } catch (error) {
    console.error("\nDatabase reset failed:", error);
    process.exit(1);
  } finally {
    await connection.end();
  }
}
<% } else if (services.database.type === 'mongodb') { -%>
async function reset(): Promise<void> {
  const client = new MongoClient(process.env.DATABASE_URL!);

  try {
    await client.connect();
    console.log("Connected to test database");

    const db = client.db();

    // Get all collection names
    const collections = await db.listCollections().toArray();
    console.log(`Found ${collections.length} collections to drop`);

    // Drop all collections
    for (const { name } of collections) {
      await db.dropCollection(name);
      console.log(`  Dropped: ${name}`);
    }

    // Seed test users
    console.log("\nSeeding test users:");
    const usersCollection = db.collection("users");

    const usersToInsert = await Promise.all(
      TEST_USERS.map(async (user) => {
        const passwordHash = await bcrypt.hash(user.password, SALT_ROUNDS);
        return {
          email: user.email.toLowerCase(),
          passwordHash,
          name: user.name,
          role: user.role,
          emailVerified: user.verified,
          createdAt: new Date(),
          updatedAt: new Date(),
        };
      })
    );

    await usersCollection.insertMany(usersToInsert);

    for (const user of TEST_USERS) {
      console.log(`  Created: ${user.email} (role: ${user.role}, verified: ${user.verified})`);
    }

    console.log("\n========================================");
    console.log("Database reset complete!");
    console.log("========================================");
    console.log("\nTest credentials:");
<% testUsers.forEach(user => { -%>
    console.log("  <%= user.name || 'User' %>: <%= user.email %> / <%= user.password %>");
<% }); -%>
    console.log("");

  } catch (error) {
    console.error("\nDatabase reset failed:", error);
    process.exit(1);
  } finally {
    await client.close();
  }
}
<% } -%>

// Run the reset
reset();
